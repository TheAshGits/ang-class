"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

exports.__esModule = true;
exports.formatAsTests = formatAsTests;

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var path = _interopRequireWildcard(require("path"));

var _util = require("../util");

function formatAsTests(failures, config) {
  var _getOutputMessage;

  var reportName = config.reportName;
  var output = [];
  var errorCount = 0;
  var warningCount = 0;
  output.push((0, _util.getOutputMessage)(_util.TeamCityMessages.TEST_SUITE_STARTED, {
    report: reportName
  })); // group failures per file, instead of reporting each failure individually

  var failuresByFile = failures.reduce(function (acc, f) {
    var file = f.getFileName();
    if (!acc[file]) acc[file] = {
      filePath: file,
      messages: []
    };
    acc[file].messages.push(f);
    return acc;
  }, {});
  (0, _values.default)(failuresByFile).forEach(function (result) {
    var filePath = path.relative(process.cwd(), result.filePath);
    output.push((0, _util.getOutputMessage)(_util.TeamCityMessages.TEST_STARTED, {
      report: reportName,
      file: filePath
    }));
    var errorsList = [];
    var warningsList = [];
    result.messages.forEach(function (failure) {
      var startPos = failure.getStartPosition().getLineAndCharacter();
      var formattedMessage = "line " + startPos.line + ", col " + startPos.character + ", " + failure.getFailure() + " (" + failure.getRuleName() + ")";
      var isError = failure.getRuleSeverity() === 'error';

      if (!isError) {
        warningsList.push(formattedMessage);
        warningCount += 1;
      } else {
        errorsList.push(formattedMessage);
        errorCount += 1;
      }
    }); // Group errors and warnings together per file

    if (errorsList.length) {
      var errors = errorsList.join('\n');
      output.push((0, _util.getOutputMessage)(_util.TeamCityMessages.TEST_FAILED, {
        errors: errors,
        report: reportName,
        file: filePath
      }));
    }

    if (warningsList.length) {
      var warnings = warningsList.join('\n');
      output.push((0, _util.getOutputMessage)(_util.TeamCityMessages.TEST_STD_OUT, {
        warnings: warnings,
        report: reportName,
        file: filePath
      }));
    }

    output.push((0, _util.getOutputMessage)(_util.TeamCityMessages.TEST_FINISHED, {
      report: reportName,
      file: filePath
    }));
  });
  output.push((0, _util.getOutputMessage)(_util.TeamCityMessages.TEST_SUITE_FINISHED, {
    report: reportName
  }));
  output.push.apply(output, (0, _util.getOutputMessage)(_util.TeamCityMessages.BUILD_STATISTIC_VALUE, (_getOutputMessage = {}, _getOutputMessage[config.errorStatisticsName] = errorCount, _getOutputMessage[config.warningStatisticsName] = warningCount, _getOutputMessage)));
  return output.join('\n');
}