{"ast":null,"code":"var _construct = require(\"/Users/ashleighkeplinger/Documents/GitHub/ang-class/node_modules/@babel/runtime/helpers/construct\");\n\nvar _toConsumableArray = require(\"/Users/ashleighkeplinger/Documents/GitHub/ang-class/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createClass = require(\"/Users/ashleighkeplinger/Documents/GitHub/ang-class/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/ashleighkeplinger/Documents/GitHub/ang-class/node_modules/@babel/runtime/helpers/classCallCheck\");\n\n/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis}\n   */\n\n  var NEWLINE = '\\n';\n  var IGNORE_FRAMES = {};\n  var creationTrace = '__creationTrace__';\n  var ERROR_TAG = 'STACKTRACE TRACKING';\n  var SEP_TAG = '__SEP_TAG__';\n  var sepTemplate = SEP_TAG + '@[native]';\n\n  var LongStackTrace = function LongStackTrace() {\n    _classCallCheck(this, LongStackTrace);\n\n    this.error = getStacktrace();\n    this.timestamp = new Date();\n  };\n\n  function getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n  }\n\n  function getStacktraceWithCaughtError() {\n    try {\n      throw getStacktraceWithUncaughtError();\n    } catch (err) {\n      return err;\n    }\n  } // Some implementations of exception handling don't create a stack trace if the exception\n  // isn't thrown, however it's faster not to actually throw the exception.\n\n\n  var error = getStacktraceWithUncaughtError();\n  var caughtError = getStacktraceWithCaughtError();\n  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\n  function getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n  }\n\n  function addErrorStack(lines, error) {\n    var trace = getFrames(error);\n\n    for (var i = 0; i < trace.length; i++) {\n      var frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n        lines.push(trace[i]);\n      }\n    }\n  }\n\n  function renderLongStackTrace(frames, stack) {\n    var longTrace = [stack ? stack.trim() : ''];\n\n    if (frames) {\n      var timestamp = new Date().getTime();\n\n      for (var i = 0; i < frames.length; i++) {\n        var traceFrames = frames[i];\n        var lastTime = traceFrames.timestamp;\n        var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n        separator = separator.replace(/[^\\w\\d]/g, '_');\n        longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n        addErrorStack(longTrace, traceFrames.error);\n        timestamp = lastTime.getTime();\n      }\n    }\n\n    return longTrace.join(NEWLINE);\n  } // if Error.stackTraceLimit is 0, means stack trace\n  // is disabled, so we don't need to generate long stack trace\n  // this will improve performance in some test(some test will\n  // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\n  function stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n  }\n\n  Zone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function getLongStackTrace(error) {\n      if (!error) {\n        return undefined;\n      }\n\n      var trace = error[Zone.__symbol__('currentTaskTrace')];\n\n      if (!trace) {\n        return error.stack;\n      }\n\n      return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n      if (stackTracesEnabled()) {\n        var currentTask = Zone.currentTask;\n        var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n        trace = [new LongStackTrace()].concat(trace);\n\n        if (trace.length > this.longStackTraceLimit) {\n          trace.length = this.longStackTraceLimit;\n        }\n\n        if (!task.data) task.data = {};\n\n        if (task.type === 'eventTask') {\n          // Fix issue https://github.com/angular/zone.js/issues/1195,\n          // For event task of browser, by default, all task will share a\n          // singleton instance of data object, we should create a new one here\n          // The cast to `any` is required to workaround a closure bug which wrongly applies\n          // URL sanitization rules to .data access.\n          task.data = Object.assign({}, task.data);\n        }\n\n        task.data[creationTrace] = trace;\n      }\n\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      if (stackTracesEnabled()) {\n        var parentTask = Zone.currentTask || error.task;\n\n        if (error instanceof Error && parentTask) {\n          var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n          try {\n            error.stack = error.longStack = longStack;\n          } catch (err) {}\n        }\n      }\n\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  };\n\n  function captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n      stackTraces.push(getFrames(new LongStackTrace().error));\n      captureStackTraces(stackTraces, count - 1);\n    }\n  }\n\n  function computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n      return;\n    }\n\n    var frames = [];\n    captureStackTraces(frames, 2);\n    var frames1 = frames[0];\n    var frames2 = frames[1];\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n\n      if (frame1.indexOf(ERROR_TAG) == -1) {\n        var match = frame1.match(/^\\s*at\\s+/);\n\n        if (match) {\n          sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n          break;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < frames1.length; _i++) {\n      var _frame = frames1[_i];\n      var frame2 = frames2[_i];\n\n      if (_frame === frame2) {\n        IGNORE_FRAMES[_frame] = true;\n      } else {\n        break;\n      }\n    }\n  }\n\n  computeIgnoreFrames();\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ProxyZoneSpec = /*#__PURE__*/function () {\n    function ProxyZoneSpec() {\n      var defaultSpecDelegate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      _classCallCheck(this, ProxyZoneSpec);\n\n      this.defaultSpecDelegate = defaultSpecDelegate;\n      this.name = 'ProxyZone';\n      this._delegateSpec = null;\n      this.properties = {\n        'ProxyZoneSpec': this\n      };\n      this.propertyKeys = null;\n      this.lastTaskState = null;\n      this.isNeedToTriggerHasTask = false;\n      this.tasks = [];\n      this.setDelegate(defaultSpecDelegate);\n    }\n\n    _createClass(ProxyZoneSpec, [{\n      key: \"setDelegate\",\n      value: function setDelegate(delegateSpec) {\n        var _this = this;\n\n        var isNewDelegate = this._delegateSpec !== delegateSpec;\n        this._delegateSpec = delegateSpec;\n        this.propertyKeys && this.propertyKeys.forEach(function (key) {\n          return delete _this.properties[key];\n        });\n        this.propertyKeys = null;\n\n        if (delegateSpec && delegateSpec.properties) {\n          this.propertyKeys = Object.keys(delegateSpec.properties);\n          this.propertyKeys.forEach(function (k) {\n            return _this.properties[k] = delegateSpec.properties[k];\n          });\n        } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n        if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n          this.isNeedToTriggerHasTask = true;\n        }\n      }\n    }, {\n      key: \"getDelegate\",\n      value: function getDelegate() {\n        return this._delegateSpec;\n      }\n    }, {\n      key: \"resetDelegate\",\n      value: function resetDelegate() {\n        var delegateSpec = this.getDelegate();\n        this.setDelegate(this.defaultSpecDelegate);\n      }\n    }, {\n      key: \"tryTriggerHasTask\",\n      value: function tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n        if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n          // last delegateSpec has microTask or macroTask\n          // should call onHasTask in current delegateSpec\n          this.isNeedToTriggerHasTask = false;\n          this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n        }\n      }\n    }, {\n      key: \"removeFromTasks\",\n      value: function removeFromTasks(task) {\n        if (!this.tasks) {\n          return;\n        }\n\n        for (var i = 0; i < this.tasks.length; i++) {\n          if (this.tasks[i] === task) {\n            this.tasks.splice(i, 1);\n            return;\n          }\n        }\n      }\n    }, {\n      key: \"getAndClearPendingTasksInfo\",\n      value: function getAndClearPendingTasksInfo() {\n        if (this.tasks.length === 0) {\n          return '';\n        }\n\n        var taskInfo = this.tasks.map(function (task) {\n          var dataInfo = task.data && Object.keys(task.data).map(function (key) {\n            return key + ':' + task.data[key];\n          }).join(',');\n          return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n        });\n        var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n        this.tasks = [];\n        return pendingTasksInfo;\n      }\n    }, {\n      key: \"onFork\",\n      value: function onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n        if (this._delegateSpec && this._delegateSpec.onFork) {\n          return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n        } else {\n          return parentZoneDelegate.fork(targetZone, zoneSpec);\n        }\n      }\n    }, {\n      key: \"onIntercept\",\n      value: function onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n        if (this._delegateSpec && this._delegateSpec.onIntercept) {\n          return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n        } else {\n          return parentZoneDelegate.intercept(targetZone, delegate, source);\n        }\n      }\n    }, {\n      key: \"onInvoke\",\n      value: function onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n        if (this._delegateSpec && this._delegateSpec.onInvoke) {\n          return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n        } else {\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        }\n      }\n    }, {\n      key: \"onHandleError\",\n      value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        if (this._delegateSpec && this._delegateSpec.onHandleError) {\n          return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n        } else {\n          return parentZoneDelegate.handleError(targetZone, error);\n        }\n      }\n    }, {\n      key: \"onScheduleTask\",\n      value: function onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n          this.tasks.push(task);\n        }\n\n        if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n          return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n        } else {\n          return parentZoneDelegate.scheduleTask(targetZone, task);\n        }\n      }\n    }, {\n      key: \"onInvokeTask\",\n      value: function onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this.removeFromTasks(task);\n        }\n\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n        if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n          return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n        } else {\n          return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        }\n      }\n    }, {\n      key: \"onCancelTask\",\n      value: function onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n          this.removeFromTasks(task);\n        }\n\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n        if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n          return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n        } else {\n          return parentZoneDelegate.cancelTask(targetZone, task);\n        }\n      }\n    }, {\n      key: \"onHasTask\",\n      value: function onHasTask(delegate, current, target, hasTaskState) {\n        this.lastTaskState = hasTaskState;\n\n        if (this._delegateSpec && this._delegateSpec.onHasTask) {\n          this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n        } else {\n          delegate.hasTask(target, hasTaskState);\n        }\n      }\n    }], [{\n      key: \"get\",\n      value: function get() {\n        return Zone.current.get('ProxyZoneSpec');\n      }\n    }, {\n      key: \"isLoaded\",\n      value: function isLoaded() {\n        return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n      }\n    }, {\n      key: \"assertPresent\",\n      value: function assertPresent() {\n        if (!ProxyZoneSpec.isLoaded()) {\n          throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n        }\n\n        return ProxyZoneSpec.get();\n      }\n    }]);\n\n    return ProxyZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var SyncTestZoneSpec = /*#__PURE__*/function () {\n    function SyncTestZoneSpec(namePrefix) {\n      _classCallCheck(this, SyncTestZoneSpec);\n\n      this.runZone = Zone.current;\n      this.name = 'syncTestZone for ' + namePrefix;\n    }\n\n    _createClass(SyncTestZoneSpec, [{\n      key: \"onScheduleTask\",\n      value: function onScheduleTask(delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n          case 'macroTask':\n            throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test.\"));\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      }\n    }]);\n\n    return SyncTestZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function __extends(d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n    if (!Zone) throw new Error('Missing: zone.js');\n\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n    // error if any asynchronous operations are attempted inside of a `describe` but outside of\n    // a `beforeEach` or `it`.\n\n    var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n    var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n    if (!ignoreUnhandledRejection) {\n      var globalErrors = jasmine.GlobalErrors;\n\n      if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors;\n\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors();\n          var originalInstall = instance.install;\n\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n\n            instance.install = function () {\n              var originalHandlers = process.listeners('unhandledRejection');\n              var r = originalInstall.apply(this, arguments);\n              process.removeAllListeners('unhandledRejection');\n\n              if (originalHandlers) {\n                originalHandlers.forEach(function (h) {\n                  return process.on('unhandledRejection', h);\n                });\n              }\n\n              return r;\n            };\n          }\n\n          return instance;\n        };\n      }\n    } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn = jasmine[symbol('clock')] = jasmine['clock'];\n\n      jasmine['clock'] = function () {\n        var clock = originalClockFn.apply(this, arguments);\n\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick = clock[symbol('tick')] = clock.tick;\n\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n\n            return originalTick.apply(this, arguments);\n          };\n\n          var originalMockDate = clock[symbol('mockDate')] = clock.mockDate;\n\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setCurrentRealTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n\n            return originalMockDate.apply(this, arguments);\n          }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n\n        return clock;\n      };\n    } // monkey patch createSpyObj to make properties enumerable to true\n\n\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n      var originalCreateSpyObj = jasmine.createSpyObj;\n      jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n\n      jasmine.createSpyObj = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var propertyNames = args.length >= 3 ? args[2] : null;\n        var spyObj;\n\n        if (propertyNames) {\n          var defineProperty = Object.defineProperty;\n\n          Object.defineProperty = function (obj, p, attributes) {\n            return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n              configurable: true,\n              enumerable: true\n            }));\n          };\n\n          try {\n            spyObj = originalCreateSpyObj.apply(this, args);\n          } finally {\n            Object.defineProperty = defineProperty;\n          }\n        } else {\n          spyObj = originalCreateSpyObj.apply(this, args);\n        }\n\n        return spyObj;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      var testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n\n\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n\n    var QueueRunner = jasmine.QueueRunner;\n\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n\n      function ZoneQueueRunner(attrs) {\n        var _this2 = this;\n\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this2.testProxyZone = null;\n              _this2.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        } // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n\n\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n\n          attrs.userContext.queueRunner = this;\n        } // patch attrs.onException\n\n\n        var onException = attrs.onException;\n\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n\n        _super.call(this, attrs);\n      }\n\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this3 = this;\n\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n\n          zone = zone.parent;\n        }\n\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this3);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('jest', function (context, Zone) {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n      return;\n    }\n\n    jest['__zone_patch__'] = true;\n\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    var proxyZone = rootZone.fork(new ProxyZoneSpec());\n\n    function wrapDescribeFactoryInZone(originalJestFn) {\n      return function () {\n        for (var _len = arguments.length, tableArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n          tableArgs[_key] = arguments[_key];\n        }\n\n        var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n        return function () {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          args[1] = wrapDescribeInZone(args[1]);\n          return originalDescribeFn.apply(this, args);\n        };\n      };\n    }\n\n    function wrapTestFactoryInZone(originalJestFn) {\n      return function () {\n        for (var _len3 = arguments.length, tableArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          tableArgs[_key3] = arguments[_key3];\n        }\n\n        return function () {\n          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            args[_key4] = arguments[_key4];\n          }\n\n          args[1] = wrapTestInZone(args[1]);\n          return originalJestFn.apply(this, tableArgs).apply(this, args);\n        };\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        return syncZone.run(describeBody, this, args);\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `proxyZone`.\n     */\n\n\n    function wrapTestInZone(testBody) {\n      if (typeof testBody !== 'function') {\n        return testBody;\n      }\n\n      var wrappedFunc = function wrappedFunc() {\n        return proxyZone.run(testBody, null, arguments);\n      }; // Update the length of wrappedFunc to be the same as the length of the testBody\n      // So jest core can handle whether the test function has `done()` or not correctly\n\n\n      Object.defineProperty(wrappedFunc, 'length', {\n        configurable: true,\n        writable: true,\n        enumerable: false\n      });\n      wrappedFunc.length = testBody.length;\n      return wrappedFunc;\n    }\n\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          args[_key7] = arguments[_key7];\n        }\n\n        args[1] = wrapTestInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n      context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n          args[_key8] = arguments[_key8];\n        }\n\n        args[0] = wrapTestInZone(args[0]);\n        return originalJestFn.apply(this, args);\n      };\n    });\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('mocha', function (global, Zone) {\n    var Mocha = global.Mocha;\n\n    if (typeof Mocha === 'undefined') {\n      // return if Mocha is not available, because now zone-testing\n      // will load mocha patch with jasmine/jest patch\n      return;\n    }\n\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    if (Mocha['__zone_patch__']) {\n      throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n\n    Mocha['__zone_patch__'] = true;\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    var testZone = null;\n    var suiteZone = rootZone.fork(new ProxyZoneSpec());\n    var mochaOriginal = {\n      after: Mocha.after,\n      afterEach: Mocha.afterEach,\n      before: Mocha.before,\n      beforeEach: Mocha.beforeEach,\n      describe: Mocha.describe,\n      it: Mocha.it\n    };\n\n    function modifyArguments(args, syncTest, asyncTest) {\n      var _loop = function _loop(i) {\n        var arg = args[i];\n\n        if (typeof arg === 'function') {\n          // The `done` callback is only passed through if the function expects at\n          // least one argument.\n          // Note we have to make a function with correct number of arguments,\n          // otherwise mocha will\n          // think that all functions are sync or async.\n          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n          // correct function body\n\n          args[i].toString = function () {\n            return arg.toString();\n          };\n        }\n      };\n\n      for (var i = 0; i < args.length; i++) {\n        _loop(i);\n      }\n\n      return args;\n    }\n\n    function wrapDescribeInZone(args) {\n      var syncTest = function syncTest(fn) {\n        return function () {\n          return syncZone.run(fn, this, arguments);\n        };\n      };\n\n      return modifyArguments(args, syncTest);\n    }\n\n    function wrapTestInZone(args) {\n      var asyncTest = function asyncTest(fn) {\n        return function (done) {\n          return testZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function syncTest(fn) {\n        return function () {\n          return testZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    function wrapSuiteInZone(args) {\n      var asyncTest = function asyncTest(fn) {\n        return function (done) {\n          return suiteZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function syncTest(fn) {\n        return function () {\n          return suiteZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    global.describe = global.suite = Mocha.describe = function () {\n      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.describe.only = global.suite.only = Mocha.describe.only = function () {\n      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.it = global.specify = global.test = Mocha.it = function () {\n      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.xit = global.xspecify = Mocha.it.skip = function () {\n      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.it.only = global.test.only = Mocha.it.only = function () {\n      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.after = global.suiteTeardown = Mocha.after = function () {\n      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.afterEach = global.teardown = Mocha.afterEach = function () {\n      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.before = global.suiteSetup = Mocha.before = function () {\n      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.beforeEach = global.setup = Mocha.beforeEach = function () {\n      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    (function (originalRunTest, originalRun) {\n      Mocha.Runner.prototype.runTest = function (fn) {\n        var _this4 = this;\n\n        Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n          originalRunTest.call(_this4, fn);\n        });\n      };\n\n      Mocha.Runner.prototype.run = function (fn) {\n        this.on('test', function (e) {\n          testZone = rootZone.fork(new ProxyZoneSpec());\n        });\n        this.on('fail', function (test, err) {\n          var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n          if (proxyZoneSpec && err) {\n            try {\n              // try catch here in case err.message is not writable\n              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n            } catch (error) {}\n          }\n        });\n        return originalRun.call(this, fn);\n      };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (_global) {\n    var AsyncTestZoneSpec = /*#__PURE__*/function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        _classCallCheck(this, AsyncTestZoneSpec);\n\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n\n      _createClass(AsyncTestZoneSpec, [{\n        key: \"isUnresolvedChainedPromisePending\",\n        value: function isUnresolvedChainedPromisePending() {\n          return this.unresolvedChainedPromiseCount > 0;\n        }\n      }, {\n        key: \"_finishCallbackIfDone\",\n        value: function _finishCallbackIfDone() {\n          var _this5 = this;\n\n          if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n            // We do this because we would like to catch unhandled rejected promises.\n            this.runZone.run(function () {\n              setTimeout(function () {\n                if (!_this5._alreadyErrored && !(_this5._pendingMicroTasks || _this5._pendingMacroTasks)) {\n                  _this5.finishCallback();\n                }\n              }, 0);\n            });\n          }\n        }\n      }, {\n        key: \"patchPromiseForTest\",\n        value: function patchPromiseForTest() {\n          if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n          }\n\n          var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n          if (patchPromiseForTest) {\n            patchPromiseForTest();\n          }\n        }\n      }, {\n        key: \"unPatchPromiseForTest\",\n        value: function unPatchPromiseForTest() {\n          if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n          }\n\n          var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n          if (unPatchPromiseForTest) {\n            unPatchPromiseForTest();\n          }\n        }\n      }, {\n        key: \"onScheduleTask\",\n        value: function onScheduleTask(delegate, current, target, task) {\n          if (task.type !== 'eventTask') {\n            this._isSync = false;\n          }\n\n          if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n            // check whether the promise is a chained promise\n            if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n              // chained promise is being scheduled\n              this.unresolvedChainedPromiseCount--;\n            }\n          }\n\n          return delegate.scheduleTask(target, task);\n        }\n      }, {\n        key: \"onInvokeTask\",\n        value: function onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n          if (task.type !== 'eventTask') {\n            this._isSync = false;\n          }\n\n          return delegate.invokeTask(target, task, applyThis, applyArgs);\n        }\n      }, {\n        key: \"onCancelTask\",\n        value: function onCancelTask(delegate, current, target, task) {\n          if (task.type !== 'eventTask') {\n            this._isSync = false;\n          }\n\n          return delegate.cancelTask(target, task);\n        } // Note - we need to use onInvoke at the moment to call finish when a test is\n        // fully synchronous. TODO(juliemr): remove this when the logic for\n        // onHasTask changes and it calls whenever the task queues are dirty.\n        // updated by(JiaLiPassion), only call finish callback when no task\n        // was scheduled/invoked/canceled.\n\n      }, {\n        key: \"onInvoke\",\n        value: function onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n          try {\n            this._isSync = true;\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n          } finally {\n            var afterTaskCounts = parentZoneDelegate._taskCounts;\n\n            if (this._isSync) {\n              this._finishCallbackIfDone();\n            }\n          }\n        }\n      }, {\n        key: \"onHandleError\",\n        value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n          // Let the parent try to handle the error.\n          var result = parentZoneDelegate.handleError(targetZone, error);\n\n          if (result) {\n            this.failCallback(error);\n            this._alreadyErrored = true;\n          }\n\n          return false;\n        }\n      }, {\n        key: \"onHasTask\",\n        value: function onHasTask(delegate, current, target, hasTaskState) {\n          delegate.hasTask(target, hasTaskState);\n\n          if (hasTaskState.change == 'microTask') {\n            this._pendingMicroTasks = hasTaskState.microTask;\n\n            this._finishCallbackIfDone();\n          } else if (hasTaskState.change == 'macroTask') {\n            this._pendingMacroTasks = hasTaskState.macroTask;\n\n            this._finishCallbackIfDone();\n          }\n        }\n      }]);\n\n      return AsyncTestZoneSpec;\n    }();\n\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function done() {};\n\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      } // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n\n\n      return function () {\n        var _this6 = this;\n\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this6, finishCallback, failCallback);\n        });\n      };\n    };\n\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/async-test.js');\n      }\n\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n      if (ProxyZoneSpec === undefined) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // sill this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (global) {\n    var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return _construct(OriginalDate, _toConsumableArray(args));\n      }\n    }\n\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n      }\n\n      return OriginalDate.now.apply(this, arguments);\n    };\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler = /*#__PURE__*/function () {\n      function Scheduler() {\n        _classCallCheck(this, Scheduler);\n\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTime = 0; // Current real time in millis.\n\n        this._currentRealTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      _createClass(Scheduler, [{\n        key: \"getCurrentTime\",\n        value: function getCurrentTime() {\n          return this._currentTime;\n        }\n      }, {\n        key: \"getCurrentRealTime\",\n        value: function getCurrentRealTime() {\n          return this._currentRealTime;\n        }\n      }, {\n        key: \"setCurrentRealTime\",\n        value: function setCurrentRealTime(realTime) {\n          this._currentRealTime = realTime;\n        }\n      }, {\n        key: \"scheduleFunction\",\n        value: function scheduleFunction(cb, delay, options) {\n          options = Object.assign({\n            args: [],\n            isPeriodic: false,\n            isRequestAnimationFrame: false,\n            id: -1,\n            isRequeuePeriodic: false\n          }, options);\n          var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n          var endTime = this._currentTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n          var newEntry = {\n            endTime: endTime,\n            id: currentId,\n            func: cb,\n            args: options.args,\n            delay: delay,\n            isPeriodic: options.isPeriodic,\n            isRequestAnimationFrame: options.isRequestAnimationFrame\n          };\n\n          if (options.isRequeuePeriodic) {\n            this._currentTickRequeuePeriodicEntries.push(newEntry);\n          }\n\n          var i = 0;\n\n          for (; i < this._schedulerQueue.length; i++) {\n            var currentEntry = this._schedulerQueue[i];\n\n            if (newEntry.endTime < currentEntry.endTime) {\n              break;\n            }\n          }\n\n          this._schedulerQueue.splice(i, 0, newEntry);\n\n          return currentId;\n        }\n      }, {\n        key: \"removeScheduledFunctionWithId\",\n        value: function removeScheduledFunctionWithId(id) {\n          for (var i = 0; i < this._schedulerQueue.length; i++) {\n            if (this._schedulerQueue[i].id == id) {\n              this._schedulerQueue.splice(i, 1);\n\n              break;\n            }\n          }\n        }\n      }, {\n        key: \"tick\",\n        value: function tick() {\n          var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var doTick = arguments.length > 1 ? arguments[1] : undefined;\n          var tickOptions = arguments.length > 2 ? arguments[2] : undefined;\n          var finalTime = this._currentTime + millis;\n          var lastCurrentTime = 0;\n          tickOptions = Object.assign({\n            processNewMacroTasksSynchronously: true\n          }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n          // will not be wrongly called in the current tick\n          // https://github.com/angular/angular/issues/33799\n\n          var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n          if (schedulerQueue.length === 0 && doTick) {\n            doTick(millis);\n            return;\n          }\n\n          while (schedulerQueue.length > 0) {\n            // clear requeueEntries before each loop\n            this._currentTickRequeuePeriodicEntries = [];\n            var current = schedulerQueue[0];\n\n            if (finalTime < current.endTime) {\n              // Done processing the queue since it's sorted by endTime.\n              break;\n            } else {\n              // Time to run scheduled function. Remove it from the head of queue.\n              var _current = schedulerQueue.shift();\n\n              if (!tickOptions.processNewMacroTasksSynchronously) {\n                var idx = this._schedulerQueue.indexOf(_current);\n\n                if (idx >= 0) {\n                  this._schedulerQueue.splice(idx, 1);\n                }\n              }\n\n              lastCurrentTime = this._currentTime;\n              this._currentTime = _current.endTime;\n\n              if (doTick) {\n                doTick(this._currentTime - lastCurrentTime);\n              }\n\n              var retval = _current.func.apply(global, _current.isRequestAnimationFrame ? [this._currentTime] : _current.args);\n\n              if (!retval) {\n                // Uncaught exception in the current scheduled function. Stop processing the queue.\n                break;\n              } // check is there any requeue periodic entry is added in\n              // current loop, if there is, we need to add to current loop\n\n\n              if (!tickOptions.processNewMacroTasksSynchronously) {\n                this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                  var i = 0;\n\n                  for (; i < schedulerQueue.length; i++) {\n                    var currentEntry = schedulerQueue[i];\n\n                    if (newEntry.endTime < currentEntry.endTime) {\n                      break;\n                    }\n                  }\n\n                  schedulerQueue.splice(i, 0, newEntry);\n                });\n              }\n            }\n          }\n\n          lastCurrentTime = this._currentTime;\n          this._currentTime = finalTime;\n\n          if (doTick) {\n            doTick(this._currentTime - lastCurrentTime);\n          }\n        }\n      }, {\n        key: \"flush\",\n        value: function flush() {\n          var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;\n          var flushPeriodic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          var doTick = arguments.length > 2 ? arguments[2] : undefined;\n\n          if (flushPeriodic) {\n            return this.flushPeriodic(doTick);\n          } else {\n            return this.flushNonPeriodic(limit, doTick);\n          }\n        }\n      }, {\n        key: \"flushPeriodic\",\n        value: function flushPeriodic(doTick) {\n          if (this._schedulerQueue.length === 0) {\n            return 0;\n          } // Find the last task currently queued in the scheduler queue and tick\n          // till that time.\n\n\n          var startTime = this._currentTime;\n          var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n          this.tick(lastTask.endTime - startTime, doTick);\n          return this._currentTime - startTime;\n        }\n      }, {\n        key: \"flushNonPeriodic\",\n        value: function flushNonPeriodic(limit, doTick) {\n          var startTime = this._currentTime;\n          var lastCurrentTime = 0;\n          var count = 0;\n\n          while (this._schedulerQueue.length > 0) {\n            count++;\n\n            if (count > limit) {\n              throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n            } // flush only non-periodic timers.\n            // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n            if (this._schedulerQueue.filter(function (task) {\n              return !task.isPeriodic && !task.isRequestAnimationFrame;\n            }).length === 0) {\n              break;\n            }\n\n            var current = this._schedulerQueue.shift();\n\n            lastCurrentTime = this._currentTime;\n            this._currentTime = current.endTime;\n\n            if (doTick) {\n              // Update any secondary schedulers like Jasmine mock Date.\n              doTick(this._currentTime - lastCurrentTime);\n            }\n\n            var retval = current.func.apply(global, current.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            }\n          }\n\n          return this._currentTime - startTime;\n        }\n      }]);\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec = /*#__PURE__*/function () {\n      function FakeAsyncTestZoneSpec(namePrefix) {\n        var trackPendingRequestAnimationFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var macroTaskOptions = arguments.length > 2 ? arguments[2] : undefined;\n\n        _classCallCheck(this, FakeAsyncTestZoneSpec);\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      _createClass(FakeAsyncTestZoneSpec, [{\n        key: \"_fnAndFlush\",\n        value: function _fnAndFlush(fn, completers) {\n          var _this7 = this;\n\n          return function () {\n            for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n              args[_key9] = arguments[_key9];\n            }\n\n            fn.apply(global, args);\n\n            if (_this7._lastError === null) {\n              // Success\n              if (completers.onSuccess != null) {\n                completers.onSuccess.apply(global);\n              } // Flush microtasks only on success.\n\n\n              _this7.flushMicrotasks();\n            } else {\n              // Failure\n              if (completers.onError != null) {\n                completers.onError.apply(global);\n              }\n            } // Return true if there were no errors, false otherwise.\n\n\n            return _this7._lastError === null;\n          };\n        }\n      }, {\n        key: \"_dequeueTimer\",\n        value: function _dequeueTimer(id) {\n          var _this8 = this;\n\n          return function () {\n            FakeAsyncTestZoneSpec._removeTimer(_this8.pendingTimers, id);\n          };\n        }\n      }, {\n        key: \"_requeuePeriodicTimer\",\n        value: function _requeuePeriodicTimer(fn, interval, args, id) {\n          var _this9 = this;\n\n          return function () {\n            // Requeue the timer callback if it's not been canceled.\n            if (_this9.pendingPeriodicTimers.indexOf(id) !== -1) {\n              _this9._scheduler.scheduleFunction(fn, interval, {\n                args: args,\n                isPeriodic: true,\n                id: id,\n                isRequeuePeriodic: true\n              });\n            }\n          };\n        }\n      }, {\n        key: \"_dequeuePeriodicTimer\",\n        value: function _dequeuePeriodicTimer(id) {\n          var _this10 = this;\n\n          return function () {\n            FakeAsyncTestZoneSpec._removeTimer(_this10.pendingPeriodicTimers, id);\n          };\n        }\n      }, {\n        key: \"_setTimeout\",\n        value: function _setTimeout(fn, delay, args) {\n          var isTimer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n          var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n          var cb = this._fnAndFlush(fn, {\n            onSuccess: removeTimerFn,\n            onError: removeTimerFn\n          });\n\n          var id = this._scheduler.scheduleFunction(cb, delay, {\n            args: args,\n            isRequestAnimationFrame: !isTimer\n          });\n\n          if (isTimer) {\n            this.pendingTimers.push(id);\n          }\n\n          return id;\n        }\n      }, {\n        key: \"_clearTimeout\",\n        value: function _clearTimeout(id) {\n          FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n          this._scheduler.removeScheduledFunctionWithId(id);\n        }\n      }, {\n        key: \"_setInterval\",\n        value: function _setInterval(fn, interval, args) {\n          var id = Scheduler.nextId;\n          var completers = {\n            onSuccess: null,\n            onError: this._dequeuePeriodicTimer(id)\n          };\n\n          var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n          completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n          this._scheduler.scheduleFunction(cb, interval, {\n            args: args,\n            isPeriodic: true\n          });\n\n          this.pendingPeriodicTimers.push(id);\n          return id;\n        }\n      }, {\n        key: \"_clearInterval\",\n        value: function _clearInterval(id) {\n          FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n          this._scheduler.removeScheduledFunctionWithId(id);\n        }\n      }, {\n        key: \"_resetLastErrorAndThrow\",\n        value: function _resetLastErrorAndThrow() {\n          var error = this._lastError || this._uncaughtPromiseErrors[0];\n          this._uncaughtPromiseErrors.length = 0;\n          this._lastError = null;\n          throw error;\n        }\n      }, {\n        key: \"getCurrentTime\",\n        value: function getCurrentTime() {\n          return this._scheduler.getCurrentTime();\n        }\n      }, {\n        key: \"getCurrentRealTime\",\n        value: function getCurrentRealTime() {\n          return this._scheduler.getCurrentRealTime();\n        }\n      }, {\n        key: \"setCurrentRealTime\",\n        value: function setCurrentRealTime(realTime) {\n          this._scheduler.setCurrentRealTime(realTime);\n        }\n      }, {\n        key: \"lockDatePatch\",\n        value: function lockDatePatch() {\n          this.patchDateLocked = true;\n          FakeAsyncTestZoneSpec.patchDate();\n        }\n      }, {\n        key: \"unlockDatePatch\",\n        value: function unlockDatePatch() {\n          this.patchDateLocked = false;\n          FakeAsyncTestZoneSpec.resetDate();\n        }\n      }, {\n        key: \"tick\",\n        value: function tick() {\n          var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var doTick = arguments.length > 1 ? arguments[1] : undefined;\n          var tickOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n            processNewMacroTasksSynchronously: true\n          };\n          FakeAsyncTestZoneSpec.assertInZone();\n          this.flushMicrotasks();\n\n          this._scheduler.tick(millis, doTick, tickOptions);\n\n          if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n          }\n        }\n      }, {\n        key: \"flushMicrotasks\",\n        value: function flushMicrotasks() {\n          var _this11 = this;\n\n          FakeAsyncTestZoneSpec.assertInZone();\n\n          var flushErrors = function flushErrors() {\n            if (_this11._lastError !== null || _this11._uncaughtPromiseErrors.length) {\n              // If there is an error stop processing the microtask queue and rethrow the error.\n              _this11._resetLastErrorAndThrow();\n            }\n          };\n\n          while (this._microtasks.length > 0) {\n            var microtask = this._microtasks.shift();\n\n            microtask.func.apply(microtask.target, microtask.args);\n          }\n\n          flushErrors();\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(limit, flushPeriodic, doTick) {\n          FakeAsyncTestZoneSpec.assertInZone();\n          this.flushMicrotasks();\n\n          var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n          if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n          }\n\n          return elapsed;\n        }\n      }, {\n        key: \"onScheduleTask\",\n        value: function onScheduleTask(delegate, current, target, task) {\n          switch (task.type) {\n            case 'microTask':\n              var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n              // currently we know process.nextTick will have such additional\n              // arguments\n\n              var additionalArgs;\n\n              if (args) {\n                var callbackIndex = task.data.cbIdx;\n\n                if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                  additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                }\n              }\n\n              this._microtasks.push({\n                func: task.invoke,\n                args: additionalArgs,\n                target: task.data && task.data.target\n              });\n\n              break;\n\n            case 'macroTask':\n              switch (task.source) {\n                case 'setTimeout':\n                  task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                  break;\n\n                case 'setImmediate':\n                  task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                  break;\n\n                case 'setInterval':\n                  task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                  break;\n\n                case 'XMLHttpRequest.send':\n                  throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n                case 'requestAnimationFrame':\n                case 'webkitRequestAnimationFrame':\n                case 'mozRequestAnimationFrame':\n                  // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                  // (60 frames per second)\n                  task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                  break;\n\n                default:\n                  // user can define which macroTask they want to support by passing\n                  // macroTaskOptions\n                  var macroTaskOption = this.findMacroTaskOption(task);\n\n                  if (macroTaskOption) {\n                    var _args = task.data && task.data['args'];\n\n                    var delay = _args && _args.length > 1 ? _args[1] : 0;\n                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : _args;\n\n                    if (!!macroTaskOption.isPeriodic) {\n                      // periodic macroTask, use setInterval to simulate\n                      task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                      task.data.isPeriodic = true;\n                    } else {\n                      // not periodic, use setTimeout to simulate\n                      task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                    }\n\n                    break;\n                  }\n\n                  throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n              }\n\n              break;\n\n            case 'eventTask':\n              task = delegate.scheduleTask(target, task);\n              break;\n          }\n\n          return task;\n        }\n      }, {\n        key: \"onCancelTask\",\n        value: function onCancelTask(delegate, current, target, task) {\n          switch (task.source) {\n            case 'setTimeout':\n            case 'requestAnimationFrame':\n            case 'webkitRequestAnimationFrame':\n            case 'mozRequestAnimationFrame':\n              return this._clearTimeout(task.data['handleId']);\n\n            case 'setInterval':\n              return this._clearInterval(task.data['handleId']);\n\n            default:\n              // user can define which macroTask they want to support by passing\n              // macroTaskOptions\n              var macroTaskOption = this.findMacroTaskOption(task);\n\n              if (macroTaskOption) {\n                var handleId = task.data['handleId'];\n                return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n              }\n\n              return delegate.cancelTask(target, task);\n          }\n        }\n      }, {\n        key: \"onInvoke\",\n        value: function onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n          try {\n            FakeAsyncTestZoneSpec.patchDate();\n            return delegate.invoke(target, callback, applyThis, applyArgs, source);\n          } finally {\n            if (!this.patchDateLocked) {\n              FakeAsyncTestZoneSpec.resetDate();\n            }\n          }\n        }\n      }, {\n        key: \"findMacroTaskOption\",\n        value: function findMacroTaskOption(task) {\n          if (!this.macroTaskOptions) {\n            return null;\n          }\n\n          for (var i = 0; i < this.macroTaskOptions.length; i++) {\n            var macroTaskOption = this.macroTaskOptions[i];\n\n            if (macroTaskOption.source === task.source) {\n              return macroTaskOption;\n            }\n          }\n\n          return null;\n        }\n      }, {\n        key: \"onHandleError\",\n        value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n          this._lastError = error;\n          return false; // Don't propagate error to parent zone.\n        }\n      }], [{\n        key: \"assertInZone\",\n        value: function assertInZone() {\n          if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n            throw new Error('The code should be running in the fakeAsync zone to call this function');\n          }\n        }\n      }, {\n        key: \"_removeTimer\",\n        value: function _removeTimer(timers, id) {\n          var index = timers.indexOf(id);\n\n          if (index > -1) {\n            timers.splice(index, 1);\n          }\n        }\n      }, {\n        key: \"patchDate\",\n        value: function patchDate() {\n          if (!!global[Zone.__symbol__('disableDatePatching')]) {\n            // we don't want to patch global Date\n            // because in some case, global Date\n            // is already being patched, we need to provide\n            // an option to let user still use their\n            // own version of Date.\n            return;\n          }\n\n          if (global['Date'] === FakeDate) {\n            // already patched\n            return;\n          }\n\n          global['Date'] = FakeDate;\n          FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n          // because jasmine.clock().install() may\n          // have replaced the global timer\n\n          FakeAsyncTestZoneSpec.checkTimerPatch();\n        }\n      }, {\n        key: \"resetDate\",\n        value: function resetDate() {\n          if (global['Date'] === FakeDate) {\n            global['Date'] = OriginalDate;\n          }\n        }\n      }, {\n        key: \"checkTimerPatch\",\n        value: function checkTimerPatch() {\n          if (global.setTimeout !== timers.setTimeout) {\n            global.setTimeout = timers.setTimeout;\n            global.clearTimeout = timers.clearTimeout;\n          }\n\n          if (global.setInterval !== timers.setInterval) {\n            global.setInterval = timers.setInterval;\n            global.clearInterval = timers.clearInterval;\n          }\n        }\n      }]);\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      return function () {\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n              args[_key10] = arguments[_key10];\n            }\n\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick() {\n      var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var ignoreNestedTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      var pendingTimers = zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * Promise for async/fakeAsync zoneSpec test\n   * can support async operation which not supported by zone.js\n   * such as\n   * it ('test jsonp in AsyncZone', async() => {\n   *   new Promise(res => {\n   *     jsonp(url, (data) => {\n   *       // success callback\n   *       res(data);\n   *     });\n   *   }).then((jsonpResult) => {\n   *     // get jsonp result.\n   *\n   *     // user will expect AsyncZoneSpec wait for\n   *     // then, but because jsonp is not zone aware\n   *     // AsyncZone will finish before then is called.\n   *   });\n   * });\n   */\n\n\n  Zone.__load_patch('promisefortest', function (global, Zone, api) {\n    var symbolState = api.symbol('state');\n    var UNRESOLVED = null;\n    var symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        return;\n      }\n\n      oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n      Promise.prototype.then = function () {\n        var chained = oriThen.apply(this, arguments);\n\n        if (this[symbolState] === UNRESOLVED) {\n          // parent promise is unresolved.\n          var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n          if (asyncTestZoneSpec) {\n            asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n            chained[symbolParentUnresolved] = true;\n          }\n        }\n\n        return chained;\n      };\n    };\n\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n      // restore origin then\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        Promise.prototype.then = oriThen;\n        Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n      }\n    };\n  });\n});","map":{"version":3,"sources":["/Users/ashleighkeplinger/Documents/GitHub/ang-class/node_modules/zone.js/fesm2015/zone-testing.js"],"names":["factory","define","amd","NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","i","length","frame","hasOwnProperty","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","concat","type","Object","assign","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2","ProxyZoneSpec","defaultSpecDelegate","_delegateSpec","properties","propertyKeys","lastTaskState","isNeedToTriggerHasTask","tasks","setDelegate","delegateSpec","isNewDelegate","forEach","key","keys","k","macroTask","microTask","getDelegate","onHasTask","splice","taskInfo","map","dataInfo","source","pendingTasksInfo","zoneSpec","onFork","fork","delegate","onIntercept","intercept","applyThis","applyArgs","tryTriggerHasTask","onInvoke","invoke","removeFromTasks","onInvokeTask","invokeTask","onCancelTask","cancelTask","current","target","hasTaskState","hasTask","get","isLoaded","SyncTestZoneSpec","namePrefix","runZone","__load_patch","global","api","__extends","d","b","p","__","constructor","prototype","create","jest","jasmine","ambientZone","syncZone","symbol","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors","GlobalErrors","instance","originalInstall","install","originalHandlers","process","listeners","r","apply","arguments","removeAllListeners","h","on","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","call","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn","clock","originalTick","tick","fakeAsyncZoneSpec","originalMockDate","mockDate","dateTime","setCurrentRealTime","FakeAsyncTestZoneSpec","originalCreateSpyObj","createSpyObj","args","Array","slice","propertyNames","spyObj","defineProperty","obj","attributes","configurable","enumerable","describeBody","run","runInTestZone","testBody","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","message","proxyZoneSpec","getAndClearPendingTasksInfo","execute","zone","isChildOfAmbientZone","parent","context","rootZone","proxyZone","wrapDescribeFactoryInZone","originalJestFn","tableArgs","originalDescribeFn","wrapTestFactoryInZone","wrappedFunc","writable","each","describe","only","fdescribe","skip","xdescribe","todo","it","fit","xit","test","Mocha","testZone","suiteZone","mochaOriginal","after","afterEach","before","beforeEach","modifyArguments","syncTest","asyncTest","arg","toString","wrapSuiteInZone","suite","specify","xspecify","suiteTeardown","teardown","suiteSetup","setup","originalRunTest","originalRun","Runner","runTest","e","_global","AsyncTestZoneSpec","finishCallback","failCallback","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","isUnresolvedChainedPromisePending","patchPromiseForTest","Promise","unPatchPromiseForTest","symbolParentUnresolved","afterTaskCounts","_taskCounts","_finishCallbackIfDone","result","change","window","self","fail","assertPresent","getZoneWith","previousDelegate","testZoneSpec","runGuarded","OriginalDate","FakeDate","setTime","now","fakeAsyncTestZoneSpec","getCurrentRealTime","getCurrentTime","UTC","parse","timers","setInterval","clearInterval","Scheduler","_schedulerQueue","_currentTime","_currentRealTime","_currentTickRequeuePeriodicEntries","realTime","cb","delay","options","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","currentEntry","millis","doTick","tickOptions","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","shift","idx","retval","limit","flushPeriodic","flushNonPeriodic","startTime","lastTask","filter","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","pendingPeriodicTimers","pendingTimers","patchDateLocked","completers","onSuccess","flushMicrotasks","onError","_removeTimer","interval","scheduleFunction","isTimer","removeTimerFn","_dequeueTimer","_fnAndFlush","removeScheduledFunctionWithId","_dequeuePeriodicTimer","_requeuePeriodicTimer","patchDate","resetDate","assertInZone","_resetLastErrorAndThrow","flushErrors","microtask","elapsed","flush","additionalArgs","callbackIndex","cbIdx","_setTimeout","_setInterval","macroTaskOption","findMacroTaskOption","callbackArgs","_clearTimeout","_clearInterval","handleId","callback","index","checkTimerPatch","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","unlockDatePatch","resetDelegate","res","lastProxyZoneSpec","lockDatePatch","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","symbolState","UNRESOLVED","oriThen","then","chained","asyncTestZoneSpec","unpatchPromiseForTest"],"mappings":"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","sourcesContent":["/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n    factory();\n}((function () { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    const NEWLINE = '\\n';\n    const IGNORE_FRAMES = {};\n    const creationTrace = '__creationTrace__';\n    const ERROR_TAG = 'STACKTRACE TRACKING';\n    const SEP_TAG = '__SEP_TAG__';\n    let sepTemplate = SEP_TAG + '@[native]';\n    class LongStackTrace {\n        constructor() {\n            this.error = getStacktrace();\n            this.timestamp = new Date();\n        }\n    }\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    const error = getStacktraceWithUncaughtError();\n    const caughtError = getStacktraceWithCaughtError();\n    const getStacktrace = error.stack ?\n        getStacktraceWithUncaughtError :\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        let trace = getFrames(error);\n        for (let i = 0; i < trace.length; i++) {\n            const frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        const longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            let timestamp = new Date().getTime();\n            for (let i = 0; i < frames.length; i++) {\n                const traceFrames = frames[i];\n                const lastTime = traceFrames.timestamp;\n                let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10,\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            const trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                const currentTask = Zone.currentTask;\n                let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = Object.assign({}, task.data);\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                const parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames((new LongStackTrace()).error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        const frames = [];\n        captureStackTraces(frames, 2);\n        const frames1 = frames[0];\n        const frames2 = frames[1];\n        for (let i = 0; i < frames1.length; i++) {\n            const frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                let match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (let i = 0; i < frames1.length; i++) {\n            const frame1 = frames1[i];\n            const frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    class ProxyZoneSpec {\n        constructor(defaultSpecDelegate = null) {\n            this.defaultSpecDelegate = defaultSpecDelegate;\n            this.name = 'ProxyZone';\n            this._delegateSpec = null;\n            this.properties = { 'ProxyZoneSpec': this };\n            this.propertyKeys = null;\n            this.lastTaskState = null;\n            this.isNeedToTriggerHasTask = false;\n            this.tasks = [];\n            this.setDelegate(defaultSpecDelegate);\n        }\n        static get() {\n            return Zone.current.get('ProxyZoneSpec');\n        }\n        static isLoaded() {\n            return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n        }\n        static assertPresent() {\n            if (!ProxyZoneSpec.isLoaded()) {\n                throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);\n            }\n            return ProxyZoneSpec.get();\n        }\n        setDelegate(delegateSpec) {\n            const isNewDelegate = this._delegateSpec !== delegateSpec;\n            this._delegateSpec = delegateSpec;\n            this.propertyKeys && this.propertyKeys.forEach((key) => delete this.properties[key]);\n            this.propertyKeys = null;\n            if (delegateSpec && delegateSpec.properties) {\n                this.propertyKeys = Object.keys(delegateSpec.properties);\n                this.propertyKeys.forEach((k) => this.properties[k] = delegateSpec.properties[k]);\n            }\n            // if a new delegateSpec was set, check if we need to trigger hasTask\n            if (isNewDelegate && this.lastTaskState &&\n                (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n                this.isNeedToTriggerHasTask = true;\n            }\n        }\n        getDelegate() {\n            return this._delegateSpec;\n        }\n        resetDelegate() {\n            const delegateSpec = this.getDelegate();\n            this.setDelegate(this.defaultSpecDelegate);\n        }\n        tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n            if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n                // last delegateSpec has microTask or macroTask\n                // should call onHasTask in current delegateSpec\n                this.isNeedToTriggerHasTask = false;\n                this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n            }\n        }\n        removeFromTasks(task) {\n            if (!this.tasks) {\n                return;\n            }\n            for (let i = 0; i < this.tasks.length; i++) {\n                if (this.tasks[i] === task) {\n                    this.tasks.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        getAndClearPendingTasksInfo() {\n            if (this.tasks.length === 0) {\n                return '';\n            }\n            const taskInfo = this.tasks.map((task) => {\n                const dataInfo = task.data &&\n                    Object.keys(task.data)\n                        .map((key) => {\n                        return key + ':' + task.data[key];\n                    })\n                        .join(',');\n                return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;\n            });\n            const pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n            // clear tasks\n            this.tasks = [];\n            return pendingTasksInfo;\n        }\n        onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n            if (this._delegateSpec && this._delegateSpec.onFork) {\n                return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n            }\n            else {\n                return parentZoneDelegate.fork(targetZone, zoneSpec);\n            }\n        }\n        onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n            if (this._delegateSpec && this._delegateSpec.onIntercept) {\n                return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n            }\n            else {\n                return parentZoneDelegate.intercept(targetZone, delegate, source);\n            }\n        }\n        onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvoke) {\n                return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n            }\n            else {\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n        }\n        onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n            if (this._delegateSpec && this._delegateSpec.onHandleError) {\n                return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n            }\n            else {\n                return parentZoneDelegate.handleError(targetZone, error);\n            }\n        }\n        onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.tasks.push(task);\n            }\n            if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n                return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.scheduleTask(targetZone, task);\n            }\n        }\n        onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n                return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n            }\n            else {\n                return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n            }\n        }\n        onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n                return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.cancelTask(targetZone, task);\n            }\n        }\n        onHasTask(delegate, current, target, hasTaskState) {\n            this.lastTaskState = hasTaskState;\n            if (this._delegateSpec && this._delegateSpec.onHasTask) {\n                this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n            }\n            else {\n                delegate.hasTask(target, hasTaskState);\n            }\n        }\n    }\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    class SyncTestZoneSpec {\n        constructor(namePrefix) {\n            this.runZone = Zone.current;\n            this.name = 'syncTestZone for ' + namePrefix;\n        }\n        onScheduleTask(delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                case 'macroTask':\n                    throw new Error(`Cannot call ${task.source} from within a sync test.`);\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        }\n    }\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jasmine', (global, Zone, api) => {\n        const __extends = function (d, b) {\n            for (const p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        const ambientZone = Zone.current;\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe` but outside of\n        // a `beforeEach` or `it`.\n        const syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n        const symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            const globalErrors = jasmine.GlobalErrors;\n            if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors;\n                jasmine.GlobalErrors = function () {\n                    const instance = new globalErrors();\n                    const originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            const originalHandlers = process.listeners('unhandledRejection');\n                            const r = originalInstall.apply(this, arguments);\n                            process.removeAllListeners('unhandledRejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(h => process.on('unhandledRejection', h));\n                            }\n                            return r;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        const jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(methodName => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            const originalClockFn = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                const clock = originalClockFn.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    const originalTick = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick.apply(this, arguments);\n                    };\n                    const originalMockDate = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setCurrentRealTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(methodName => {\n                            const originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            const originalCreateSpyObj = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n            jasmine.createSpyObj = function () {\n                const args = Array.prototype.slice.call(arguments);\n                const propertyNames = args.length >= 3 ? args[2] : null;\n                let spyObj;\n                if (propertyNames) {\n                    const defineProperty = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            const testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n            const testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        const QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                if (attrs.onComplete) {\n                    attrs.onComplete = (fn => () => {\n                        // All functions are done, clear the test zone.\n                        this.testProxyZone = null;\n                        this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    })(attrs.onComplete);\n                }\n                const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                const onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        const proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                let zone = Zone.current;\n                let isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jest', (context, Zone) => {\n        if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n            return;\n        }\n        jest['__zone_patch__'] = true;\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        const rootZone = Zone.current;\n        const syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n        const proxyZone = rootZone.fork(new ProxyZoneSpec());\n        function wrapDescribeFactoryInZone(originalJestFn) {\n            return function (...tableArgs) {\n                const originalDescribeFn = originalJestFn.apply(this, tableArgs);\n                return function (...args) {\n                    args[1] = wrapDescribeInZone(args[1]);\n                    return originalDescribeFn.apply(this, args);\n                };\n            };\n        }\n        function wrapTestFactoryInZone(originalJestFn) {\n            return function (...tableArgs) {\n                return function (...args) {\n                    args[1] = wrapTestInZone(args[1]);\n                    return originalJestFn.apply(this, tableArgs).apply(this, args);\n                };\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function (...args) {\n                return syncZone.run(describeBody, this, args);\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in the `proxyZone`.\n         */\n        function wrapTestInZone(testBody) {\n            if (typeof testBody !== 'function') {\n                return testBody;\n            }\n            const wrappedFunc = function () {\n                return proxyZone.run(testBody, null, arguments);\n            };\n            // Update the length of wrappedFunc to be the same as the length of the testBody\n            // So jest core can handle whether the test function has `done()` or not correctly\n            Object.defineProperty(wrappedFunc, 'length', { configurable: true, writable: true, enumerable: false });\n            wrappedFunc.length = testBody.length;\n            return wrappedFunc;\n        }\n        ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n            let originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function (...args) {\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n        });\n        context.describe.only = context.fdescribe;\n        context.describe.skip = context.xdescribe;\n        ['it', 'xit', 'fit', 'test', 'xtest'].forEach(methodName => {\n            let originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function (...args) {\n                args[1] = wrapTestInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n            context[methodName].todo = originalJestFn.todo;\n        });\n        context.it.only = context.fit;\n        context.it.skip = context.xit;\n        context.test.only = context.fit;\n        context.test.skip = context.xit;\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n            let originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function (...args) {\n                args[0] = wrapTestInZone(args[0]);\n                return originalJestFn.apply(this, args);\n            };\n        });\n    });\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('mocha', (global, Zone) => {\n        const Mocha = global.Mocha;\n        if (typeof Mocha === 'undefined') {\n            // return if Mocha is not available, because now zone-testing\n            // will load mocha patch with jasmine/jest patch\n            return;\n        }\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        if (Mocha['__zone_patch__']) {\n            throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n        }\n        Mocha['__zone_patch__'] = true;\n        const rootZone = Zone.current;\n        const syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n        let testZone = null;\n        const suiteZone = rootZone.fork(new ProxyZoneSpec());\n        const mochaOriginal = {\n            after: Mocha.after,\n            afterEach: Mocha.afterEach,\n            before: Mocha.before,\n            beforeEach: Mocha.beforeEach,\n            describe: Mocha.describe,\n            it: Mocha.it\n        };\n        function modifyArguments(args, syncTest, asyncTest) {\n            for (let i = 0; i < args.length; i++) {\n                let arg = args[i];\n                if (typeof arg === 'function') {\n                    // The `done` callback is only passed through if the function expects at\n                    // least one argument.\n                    // Note we have to make a function with correct number of arguments,\n                    // otherwise mocha will\n                    // think that all functions are sync or async.\n                    args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                    // Mocha uses toString to view the test body in the result list, make sure we return the\n                    // correct function body\n                    args[i].toString = function () {\n                        return arg.toString();\n                    };\n                }\n            }\n            return args;\n        }\n        function wrapDescribeInZone(args) {\n            const syncTest = function (fn) {\n                return function () {\n                    return syncZone.run(fn, this, arguments);\n                };\n            };\n            return modifyArguments(args, syncTest);\n        }\n        function wrapTestInZone(args) {\n            const asyncTest = function (fn) {\n                return function (done) {\n                    return testZone.run(fn, this, [done]);\n                };\n            };\n            const syncTest = function (fn) {\n                return function () {\n                    return testZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        function wrapSuiteInZone(args) {\n            const asyncTest = function (fn) {\n                return function (done) {\n                    return suiteZone.run(fn, this, [done]);\n                };\n            };\n            const syncTest = function (fn) {\n                return function () {\n                    return suiteZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        global.describe = global.suite = Mocha.describe = function () {\n            return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n            return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.describe.only = global.suite.only = Mocha.describe.only = function () {\n            return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.it = global.specify = global.test = Mocha.it = function () {\n            return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n        };\n        global.xit = global.xspecify = Mocha.it.skip = function () {\n            return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n        };\n        global.it.only = global.test.only = Mocha.it.only = function () {\n            return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n        };\n        global.after = global.suiteTeardown = Mocha.after = function () {\n            return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.afterEach = global.teardown = Mocha.afterEach = function () {\n            return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n        };\n        global.before = global.suiteSetup = Mocha.before = function () {\n            return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.beforeEach = global.setup = Mocha.beforeEach = function () {\n            return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n        };\n        ((originalRunTest, originalRun) => {\n            Mocha.Runner.prototype.runTest = function (fn) {\n                Zone.current.scheduleMicroTask('mocha.forceTask', () => {\n                    originalRunTest.call(this, fn);\n                });\n            };\n            Mocha.Runner.prototype.run = function (fn) {\n                this.on('test', (e) => {\n                    testZone = rootZone.fork(new ProxyZoneSpec());\n                });\n                this.on('fail', (test, err) => {\n                    const proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                    if (proxyZoneSpec && err) {\n                        try {\n                            // try catch here in case err.message is not writable\n                            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                        }\n                        catch (error) {\n                        }\n                    }\n                });\n                return originalRun.call(this, fn);\n            };\n        })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n    });\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (_global) {\n        class AsyncTestZoneSpec {\n            constructor(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            isUnresolvedChainedPromisePending() {\n                return this.unresolvedChainedPromiseCount > 0;\n            }\n            _finishCallbackIfDone() {\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                    // We do this because we would like to catch unhandled rejected promises.\n                    this.runZone.run(() => {\n                        setTimeout(() => {\n                            if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n                                this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            }\n            patchPromiseForTest() {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            }\n            unPatchPromiseForTest() {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            }\n            onScheduleTask(delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            }\n            onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            }\n            onCancelTask(delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            }\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    const afterTaskCounts = parentZoneDelegate._taskCounts;\n                    if (this._isSync) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            }\n            onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                const result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            }\n            onHasTask(delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            }\n        }\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('asynctest', (global, Zone, api) => {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, (err) => {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                return new Promise((finishCallback, failCallback) => {\n                    runInTestZone(fn, this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            const currentZone = Zone.current;\n            const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/async-test.js');\n            }\n            const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (ProxyZoneSpec === undefined) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/proxy.js');\n            }\n            const proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            const previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(() => {\n                const testZoneSpec = new AsyncTestZoneSpec(() => {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // sill this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(() => {\n                        finishCallback();\n                    });\n                }, (error) => {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(() => {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        const OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                const d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                const args = Array.prototype.slice.call(arguments);\n                return new OriginalDate(...args);\n            }\n        }\n        FakeDate.now =\n            function () {\n                const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncTestZoneSpec) {\n                    return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n                }\n                return OriginalDate.now.apply(this, arguments);\n            };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        const timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        class Scheduler {\n            constructor() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTime = 0;\n                // Current real time in millis.\n                this._currentRealTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            getCurrentTime() {\n                return this._currentTime;\n            }\n            getCurrentRealTime() {\n                return this._currentRealTime;\n            }\n            setCurrentRealTime(realTime) {\n                this._currentRealTime = realTime;\n            }\n            scheduleFunction(cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                let endTime = this._currentTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                let newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                let i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    let currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            }\n            removeScheduledFunctionWithId(id) {\n                for (let i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n            tick(millis = 0, doTick, tickOptions) {\n                let finalTime = this._currentTime + millis;\n                let lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    let current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        let current = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            const idx = this._schedulerQueue.indexOf(current);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTime;\n                        this._currentTime = current.endTime;\n                        if (doTick) {\n                            doTick(this._currentTime - lastCurrentTime);\n                        }\n                        let retval = current.func.apply(global, current.isRequestAnimationFrame ? [this._currentTime] : current.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(newEntry => {\n                                let i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    const currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTime;\n                this._currentTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTime - lastCurrentTime);\n                }\n            }\n            flush(limit = 20, flushPeriodic = false, doTick) {\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            }\n            flushPeriodic(doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                const startTime = this._currentTime;\n                const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTime - startTime;\n            }\n            flushNonPeriodic(limit, doTick) {\n                const startTime = this._currentTime;\n                let lastCurrentTime = 0;\n                let count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(task => !task.isPeriodic && !task.isRequestAnimationFrame)\n                        .length === 0) {\n                        break;\n                    }\n                    const current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTime;\n                    this._currentTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTime - lastCurrentTime);\n                    }\n                    const retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTime - startTime;\n            }\n        }\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        class FakeAsyncTestZoneSpec {\n            constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            static assertInZone() {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            _fnAndFlush(fn, completers) {\n                return (...args) => {\n                    fn.apply(global, args);\n                    if (this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return this._lastError === null;\n                };\n            }\n            static _removeTimer(timers, id) {\n                let index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            }\n            _dequeueTimer(id) {\n                return () => {\n                    FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                };\n            }\n            _requeuePeriodicTimer(fn, interval, args, id) {\n                return () => {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        this._scheduler.scheduleFunction(fn, interval, { args, isPeriodic: true, id, isRequeuePeriodic: true });\n                    }\n                };\n            }\n            _dequeuePeriodicTimer(id) {\n                return () => {\n                    FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                };\n            }\n            _setTimeout(fn, delay, args, isTimer = true) {\n                let removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                let cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                let id = this._scheduler.scheduleFunction(cb, delay, { args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            }\n            _clearTimeout(id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            }\n            _setInterval(fn, interval, args) {\n                let id = Scheduler.nextId;\n                let completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                let cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            }\n            _clearInterval(id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            }\n            _resetLastErrorAndThrow() {\n                let error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            }\n            getCurrentTime() {\n                return this._scheduler.getCurrentTime();\n            }\n            getCurrentRealTime() {\n                return this._scheduler.getCurrentRealTime();\n            }\n            setCurrentRealTime(realTime) {\n                this._scheduler.setCurrentRealTime(realTime);\n            }\n            static patchDate() {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            }\n            static resetDate() {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            }\n            static checkTimerPatch() {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            }\n            lockDatePatch() {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            }\n            unlockDatePatch() {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            }\n            tick(millis = 0, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            }\n            flushMicrotasks() {\n                FakeAsyncTestZoneSpec.assertInZone();\n                const flushErrors = () => {\n                    if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    let microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            }\n            flush(limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            }\n            onScheduleTask(delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        let args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        let additionalArgs;\n                        if (args) {\n                            let callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                const macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    const args = task.data && task.data['args'];\n                                    const delay = args && args.length > 1 ? args[1] : 0;\n                                    let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            }\n            onCancelTask(delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        const macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            const handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            }\n            onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            }\n            findMacroTaskOption(task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (let i = 0; i < this.macroTaskOptions.length; i++) {\n                    const macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            }\n            onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            }\n        }\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('fakeasync', (global, Zone, api) => {\n        const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        const ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n        let _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            return function (...args) {\n                const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    let res;\n                    const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n                            `periodic timer(s) still in the queue.`);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis = 0, ignoreNestedTimeout = false) {\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            const zoneSpec = _getFakeAsyncZoneSpec();\n            const pendingTimers = zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone, flushMicrotasks, discardPeriodicTasks, tick, flush, fakeAsync };\n    });\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Promise for async/fakeAsync zoneSpec test\n     * can support async operation which not supported by zone.js\n     * such as\n     * it ('test jsonp in AsyncZone', async() => {\n     *   new Promise(res => {\n     *     jsonp(url, (data) => {\n     *       // success callback\n     *       res(data);\n     *     });\n     *   }).then((jsonpResult) => {\n     *     // get jsonp result.\n     *\n     *     // user will expect AsyncZoneSpec wait for\n     *     // then, but because jsonp is not zone aware\n     *     // AsyncZone will finish before then is called.\n     *   });\n     * });\n     */\n    Zone.__load_patch('promisefortest', (global, Zone, api) => {\n        const symbolState = api.symbol('state');\n        const UNRESOLVED = null;\n        const symbolParentUnresolved = api.symbol('parentUnresolved');\n        // patch Promise.prototype.then to keep an internal\n        // number for tracking unresolved chained promise\n        // we will decrease this number when the parent promise\n        // being resolved/rejected and chained promise was\n        // scheduled as a microTask.\n        // so we can know such kind of chained promise still\n        // not resolved in AsyncTestZone\n        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n            let oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                return;\n            }\n            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n            Promise.prototype.then = function () {\n                const chained = oriThen.apply(this, arguments);\n                if (this[symbolState] === UNRESOLVED) {\n                    // parent promise is unresolved.\n                    const asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                    if (asyncTestZoneSpec) {\n                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                        chained[symbolParentUnresolved] = true;\n                    }\n                }\n                return chained;\n            };\n        };\n        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n            // restore origin then\n            const oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                Promise.prototype.then = oriThen;\n                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n            }\n        };\n    });\n\n})));\n"]},"metadata":{},"sourceType":"script"}